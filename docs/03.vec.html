<html><head><link href="paren-soup-light.css" rel="stylesheet" type="text/css" /><link href="style.css" rel="stylesheet" type="text/css" /></head><body><h2>Vectors and Sets</h2><p>Now that we understand the difference between the reader and the evaluator, let's make our own reader. We'll start by coming up with a line that contains different things we want to parse:</p><pre><code>42 0.5 1/2 foo-bar
</code></pre><p>To begin, we'll store this text in a string and put it in a var:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(def text "42 0.5 1/2 foo-bar")
</div></div></pre><p>Our reader will look at each character in that string and try to figure out what to do with it. To do that, we need to break it up into individual characters using the <code>vec</code> function:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(vec text)
</div></div></pre><p>You can see that the results are surrounded by square brackets, meaning it's a vector. This is a common way of storing a collection of data in Clojure. We should store that in a var as well:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(def chars (vec text))
</div></div></pre><p>We can pull out individual characters from the vector with <code>get</code>:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(get chars 0)
(get chars 1)
(get chars 2)
</div></div></pre><p>To make this a bit easier, we'll focus on the first character. Let's store it in a var:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(def first-char (get chars 0))
</div></div></pre><p>We know this character happens to be a digit, but how would we determine that with code? There are only 10 digits, so let's just make a vector that contains all of them. Notice that we are using a special backslash syntax to write each character, instead of surrounding them in double quotes. This is normally how they are written:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(def digits [\1 \2 \3 \4 \5 \6 \7 \8 \9 \0])
</div></div></pre><p>Now we want to figure out if <code>first-char</code> is inside of <code>digits</code>. One way is to use the <code>.indexOf</code> function, which will return the index of the value if it finds it:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(.indexOf digits first-char)
</div></div></pre><p>It returns 4, because the <code>\5</code> character is in the 4th position (starting with 0!). If we search for a character that isn't in there, it returns -1:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(.indexOf digits \e)
</div></div></pre><p>If the name <code>.indexOf</code> looks odd, it's because it is not actually part of Clojure; it is actually a Java method. Any time you see a function starting with a period, it is reaching down to the underlying platform. Normally Clojure tries not to duplicate functionality that already exists underneath.</p><p>While the technique above works, it's not very efficient. The <code>.indexOf</code> function works by going through every item in the vector until it finds what it's looking for. There is a much better way to check if a value is contained within a finite set of things -- and it's called a set. Let's redefine <code>digits</code> as a set:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(def digits #{\1 \2 \3 \4 \5 \6 \7 \8 \9 \0})
</div></div></pre><p>We can see that sets are surrounded by <code>#{...}</code> instead of <code>[...]</code>. One interesting thing about them is, they don't maintain order. Check it out:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">digits
</div></div></pre><p>This is the tradeoff you make between vectors and sets. Vectors maintain order, but their <code>.indexOf</code> function is slow. Sets can shuffle their contents into any arbitrary order they want, but they are very fast at checking if they contain something. Instead of using <code>.indexOf</code>, they use a Clojure function:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(contains? digits first-char)
(contains? digits \e)
</div></div></pre><p>As you can see, <code>contains?</code> just returns true or false. There would be no point to returning an index value like <code>.indexOf</code> does, since sets don't maintain order in the first place. For our purposes, that's ok, since we just want to check if the character is anywhere inside of <code>digits</code>.</p><script src="paren-soup-with-compiler.js" type="text/javascript"></script><script type="text/javascript">paren_soup.core.init_all({"disable-timeout?":true});</script><a href="02.eval.html" style="float:left;">Previous: The Evaluator</a><a href="04.fn.html" style="float:right;">Next: Functions and Lists</a></body></html>