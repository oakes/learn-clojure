<html><head><link href="paren-soup-light.css" rel="stylesheet" type="text/css" /><link href="style.css" rel="stylesheet" type="text/css" /></head><body><h2>The Reader</h2><p>The code you write begins its life merely as text – a stream of characters with no meaning at all to the computer they lie within (and possibly to the author who wrote them, for that matter). In Clojure, it is the job of the <em>reader</em> to parse that text into meaningful parts.</p><p>Imagine writing our own reader for Clojure. That may seem like a pointless thing to do since Clojure already has one (and ours will likely be buggier and less complete), but that hasn't stopped programmers from reinventing the wheel in the past. Our wheel may barely move, but it'll be <em>our</em> barely moveable wheel.</p><p>When our reader comes across <code>42</code>, it should parse it as a single number. When it comes across <code>1 2 10</code>, it should parse three separate numbers. To do this, our reader makes a rule:</p><p><em>If I come across a digit 0 through 9, keep reading until I find something that isn't a digit.</em></p><p>That works for the simplest cases, but our reader forgot about negative numbers like <code>-42</code>, so we add a rule:</p><p><em>If I come across a hyphen followed by a digit, include it in the number.</em></p><p>That's better, but there are still more things to consider, such as <code>0.5</code> and <code>1/2</code>. After adding new rules to account for decimals and ratios, our reader is getting pretty good at parsing numbers.</p><p>To reiterate, our reader receives these numbers as <em>text</em> (in particular, ASCII / UTF-8 numerals) and turns them into a format understandable by the computer, which we will generically call <em>data</em>. <strong>The reader turns text into data.</strong></p><p>While <code>0.5</code> and <code>1/2</code> are different textual representations, once they are parsed by our reader they end up more-or-less as the same data. This distinction between the text and the data that it turns into will keep coming up, and is extremely important to keep in mind. Text is for humans, data is for machines (and for humans named Rich Hickey).</p><p>In addition to numbers, our reader also needs to parse strings. In Clojure they are surrounded by double quotes:</p><pre><code>"Hello, world!"
</code></pre><p>The rule for our reader is easy enough:</p><p><em>If I come across a double quote, keep reading until I come across another double quote.</em></p><p>But we have a problem: With this rule, it's impossible to create a string that <em>contains</em> a double quote. If we want to make a string that contains <code>The " character surrounds strings</code>, we'll get an error, because our reader will stop parsing the string when it gets to the second double quote:</p><pre><code>"The " character surrounds strings"
</code></pre><p>The typical solution is <em>escaping</em> the internal double quote with a backslash character:</p><pre><code>"The \" character surrounds strings"
</code></pre><p>So we modify our rule:</p><p><em>If I come across a double quote, keep reading until I come across another double quote not preceded by a backslash.</em></p><p>Here again we see the all-important distinction between the <em>text</em> written by a programmer, and the <em>data</em> that our reader turns it into. The double quotes and escaping are all artifacts of the textual representation – that is, they exist purely to help our reader parse the string from text.</p><p>The numbers and strings above are called <em>literals</em> because they represent their value directly. It can be extremely useful to represent values indirectly, which in Clojure is done with <em>symbols</em>. Symbols are names that point to some other value.</p><pre><code>even? odd? + -
</code></pre><p>Our reader should parse four separate symbols here. So the rule boils down to...</p><p><em>If I come across a non-numeric character, keep reading until I reach whitespace.</em></p><p>Let's stick with just these three data types: numbers, strings, and symbols. Our reader doesn't know what the symbols point to; figuring that out is the job of the <em>evaluator</em>.</p><script src="paren-soup-with-compiler.js" type="text/javascript"></script><script type="text/javascript">paren_soup.core.init_all({"disable-timeout?":true});</script><a href="02.eval.html" style="float:right;">Next: The Evaluator</a></body></html>