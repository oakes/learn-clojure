<html><head><link href="paren-soup-light.css" rel="stylesheet" type="text/css" /><link href="style.css" rel="stylesheet" type="text/css" /></head><body><h2>The Evaluator</h2><p>Let's take those symbols we looked at before, but this time our reader will hand them off to the evaluator...</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">even?
odd?
+
-
</div></div></pre><p>They are all pointing to functions! But we are not actually running them; we are merely displaying them. To make the evaluator <em>invoke</em> a function, we must surround it in parens and pass whatever arguments we wish...</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(even? 7)
(odd? 7)
(+ 1 2)
(- 3 2)
</div></div></pre><p>When there are nested function calls, the evaluator invokes them, starting with the inner-most ones:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(odd? (+ 1 (- 3 2)))
</div></div></pre><p>The evaluator found these functions by looking them up in a table behind the scenes. <strong>The association of a symbol to a globally-accessible value is called a var.</strong> You can make your own var using <code>def</code>:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(def my-name "Alice")
</div></div></pre><p>While the previous vars pointed to functions, this one points to a string. Vars can point to any kind of value. Now wherever we use <code>my-name</code>, the evaluator will look up the var and return its value:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">my-name
</div></div></pre><p>Let's pass it as an argument to the <code>first</code> function and grab the first letter:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(first my-name)
</div></div></pre><p>The distinction between a symbol and a var is crucial to understand. After our reader parsed <code>my-name</code>, it was considered a symbol, and after handing it off to the evaluator, it found that it was a var and retrieved its value. Let's visualize the life of <code>my-name</code>...</p><pre><code>text   ->   symbol   ->   var
     (read)        (eval)
</code></pre><p>If the evaluator can't find what a symbol is pointing to (for example, it was not <code>def</code>ed anywhere), it will throw an error. However, there is a way to tell the evaluator to not try to resolve it:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">'this-symbol-points-to-nothing
</div></div></pre><p>By putting a single quote before a symbol, we are short-circuiting the evaluator and simply telling Clojure to let it remain as a symbol. This is not a common thing to do, because the entire point of symbols is to point to values, but we'll find some use cases in the future. For now, just keep in mind that a single quote is a simple way to shut off the evaluator.</p><script src="paren-soup-with-compiler.js" type="text/javascript"></script><script type="text/javascript">paren_soup.core.init_all({"disable-timeout?":true});</script><a href="01.read.html" style="float:left;">Previous: The Reader</a><a href="03.vec.html" style="float:right;">Next: Vectors and Sets</a></body></html>