<html><head><link href="paren-soup-light.css" rel="stylesheet" type="text/css" /><link href="style.css" rel="stylesheet" type="text/css" /></head><body><h2>Functions and Lists</h2><p>By now we've used several different functions, but we haven't yet made one. As a simple exercise, we will make a function called <code>square</code> that takes a number as an argument and returns that number multiplied by itself. So, <code>(square 2)</code> should give us 4. You can make a function using <code>fn</code>:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(fn [n] (* n n))
</div></div></pre><p>When we use <code>fn</code>, we must give it a vector of symbols representing the arguments. It could have zero or more, but in this case there is only one, which we call <code>n</code>. Then we get to the body of the function, which multiplies <code>n</code> by itself.</p><p>The only problem is, <code>fn</code> creates a function object, but there is no var we can refer to it with, so it's a bit hard to use. We can solve this using the same <code>def</code> mechanism we've used in the past:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(def square (fn [n] (* n n)))
</div></div></pre><p>Now we can call it:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(square 2)
(square 3)
(square 10)
</div></div></pre><p>It turns out that we need to define functions all the time, so there is a shorthand built into the language:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(defn square [n] (* n n))
</div></div></pre><p>So, <code>defn</code> does the equivalent of the <code>def</code> + <code>fn</code> combo above, but with a bit less typing. It's nice to see how it works underneath â€“ it's just making a function object and saving it to a var.</p><p>Let's return to our set of digits:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(def digits #{\1 \2 \3 \4 \5 \6 \7 \8 \9 \0})
</div></div></pre><p>We can now write a function that tells us if a given character is a digit. In Clojure it is common for functions that return a boolean (<code>true</code> or <code>false</code>) to end in a <code>?</code>, so we'll call it <code>digit?</code>, and the argument will be called <code>ch</code> (short for "character"):</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(defn digit? [ch]
  (contains? digits ch))
</div></div></pre><p>And it can be called as you would expect:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(digit? \7)
(digit? \u)
</div></div></pre><p>Let's bring back our vector of characters:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(def chars (vec "42 0.5 1/2 foo-bar"))
</div></div></pre><p>We know we can pull out individual values with <code>get</code>, but how could we just run our <code>digit?</code> function on every character? For that, we use <code>map</code>:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(map digit? chars)
</div></div></pre><p>There is also a closely related function that will use our <code>digit?</code> function to decide which characters to keep, and thus discard non-digit characters:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(filter digit? chars)
</div></div></pre><p>Or, if you want to do the opposite:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(remove digit? chars)
</div></div></pre><p>Notice something subtle about what these functions are returning. We've seen that normally data is stored in vectors as <code>[...]</code>, but these functions are returning their values between parens. That's because they are lists, not vectors.</p><p>There are many underlying differences between lists and vectors, but the most interesting difference for now is that lists can be <em>lazy</em>, delaying how their values are computed until the latest possible time.</p><p>For now, however, you should stick to using vectors as much as possible. You can always convert a list to a vector with the same <code>vec</code> function we've used before:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(vec (filter digit? chars))
</div></div></pre><p>There are also versions of <code>map</code> and <code>filter</code> that return vectors automatically:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(mapv digit? chars)
(filterv digit? chars)
</div></div></pre><p>One more thing about lists. We've seen before that we can make a vector of digits by writing <code>[\1 \2 \3]</code>, and a set of digits by writing <code>#{\1 \2 \3}</code>, but we can't do the equivalent for lists:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(\1 \2 \3)
</div></div></pre><p>We get an error! That's because the evaluator, as we saw previously, tries to call a function whenever it sees parens, and <code>\1</code> is not a function. In a sense, parens serve "double duty" in Clojure. They invoke functions, and they represent lists. That means, if we want to create a list, we need to "shut off" the evaluator.</p><p>We already learned how to do this. Just as we can put a single quote before a symbol to make it stay a symbol, we can put one before a list to make it stay a list:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">'(\1 \2 \3)
</div></div></pre><p>Another option is to create a list with the <code>list</code> function:</p><pre><div class="paren-soup"><div class="instarepl"></div><div class="content" contenteditable="true">(list \1 \2 \3)
</div></div></pre><p>Nonetheless, for most day-to-day tasks, you should stick with vectors when you want an ordered collection, and sets when you want to check if it contains a value. Lists aren't that useful of a data structure in most cases.</p><script src="paren-soup-with-compiler.js" type="text/javascript"></script><script type="text/javascript">paren_soup.core.init_all({"disable-timeout?":true});</script><a href="03.vec.html" style="float:left;">Previous: Vectors and Sets</a><a href="05.cond.html" style="float:right;">Next: Conditions</a></body></html>